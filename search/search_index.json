{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Tracking Matrix Decompositions","text":"<p>This repository contains code for a project around tracking decompositions of matrices.</p>"},{"location":"#api","title":"API","text":""},{"location":"#kalman","title":"Kalman","text":"<p>The Kalman module contains code related to kalman filters.</p>"},{"location":"#polar_tracking.kalman.kalman_filter","title":"kalman_filter","text":"<pre><code>kalman_filter(\n    transition_matrix: npt.NDArray,\n    observation_matrix: npt.NDArray,\n    observations: npt.NDArray,\n) -&gt; npt.NDArray\n</code></pre> <p>Computes the Kalman filter estimates for a time series</p> <p>Parameters:</p> Name Type Description Default <code>transition_matrix</code> <code>NDArray</code> <p>State transition operator, M by M matrix</p> required <code>observation_matrix</code> <code>NDArray</code> <p>Measurement operator, K by M matrix </p> required <code>observations</code> <code>NDArray</code> <p>Array of measurements, timesteps by K matrix</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>The filtered time series.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the inputs are incompatible shapes</p> Warning <p>Not Yet Implemented</p> Source code in <code>polar_tracking/kalman.py</code> <pre><code>def kalman_filter(transition_matrix: npt.NDArray, \n                  observation_matrix: npt.NDArray, \n                  observations: npt.NDArray\n    ) -&gt; npt.NDArray:\n    \"\"\"Computes the Kalman filter estimates for a time series\n\n    Args:\n        transition_matrix: State transition operator, M by M matrix\n        observation_matrix: Measurement operator, K by M matrix \n        observations: Array of measurements, timesteps by K matrix\n\n    Returns:\n        The filtered time series.\n\n    Raises:\n        ValueError: If the inputs are incompatible shapes\n\n    Warning:\n        Not Yet Implemented\n    \"\"\"\n    if not _check_compatible_shape_linear(transition_matrix, \n                                          observation_matrix, \n                                          observations):\n        raise ValueError(\"Incompatible array data shapes in kalman_filter\")\n\n    return np.zeros(1)\n</code></pre>"},{"location":"#polar_tracking.kalman.kalman_gain","title":"kalman_gain","text":"<pre><code>kalman_gain(\n    prediction_covariance: npt.NDArray,\n    measurement_operator: npt.NDArray,\n    measurement_covariance: npt.NDArray,\n) -&gt; npt.NDArray\n</code></pre> <p>Return the Kalman Gain for an Update</p> <p>Parameters:</p> Name Type Description Default <code>prediction_covariance</code> <code>NDArray</code> <p>Covariance matrix of the prediction step</p> required <code>measurement_operator</code> <code>NDArray</code> <p>Matrix representing measurement operator</p> required <code>measurement_covariance</code> <code>NDArray</code> <p>Covarience of measurement noise</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>The Kalman gain for the current timestep</p> Source code in <code>polar_tracking/kalman.py</code> <pre><code>def kalman_gain(prediction_covariance: npt.NDArray,\n                measurement_operator: npt.NDArray,\n                measurement_covariance: npt.NDArray\n    ) -&gt; npt.NDArray:\n    \"\"\"Return the Kalman Gain for an Update\n\n    Args:\n        prediction_covariance: Covariance matrix of the prediction step\n        measurement_operator: Matrix representing measurement operator\n        measurement_covariance: Covarience of measurement noise\n\n    Returns:\n        The Kalman gain for the current timestep\n    \"\"\"\n\n    innovation_covariance = measurement_operator \\\n                                @ prediction_covariance \\\n                                @ measurement_operator.T \\\n                                + measurement_covariance\n\n    kalman_gain = prediction_covariance \\\n                    @ measurement_operator.T \\\n                    @ np.linalg.inv(innovation_covariance)\n\n    return kalman_gain\n</code></pre>"},{"location":"#polar_tracking.kalman.kalman_filter_update","title":"kalman_filter_update","text":"<pre><code>kalman_filter_update(\n    measurement_matrix: npt.NDArray,\n    observation: npt.NDArray,\n    state_estimate: npt.NDArray,\n    state_covariance: npt.NDArray,\n    measurement_covariance: npt.NDArray,\n) -&gt; tuple[npt.NDArray, npt.NDArray]\n</code></pre> <p>Computes the Kalman Update Step</p> <p>Parameters:</p> Name Type Description Default <code>measurement_matrix</code> <code>NDArray</code> <p>Matrix representing the measurement operator</p> required <code>observation</code> <code>NDArray</code> <p>Current observation vector</p> required <code>state_estimate</code> <code>NDArray</code> <p>State prediction for current timestep</p> required <code>state_covariance</code> <code>NDArray</code> <p>Covariance matrix for current state prediction</p> required <code>measurement_covariance</code> <code>NDArray</code> <p>Measurement covariance matrix</p> required <p>Returns:</p> Type Description <code>tuple[NDArray, NDArray]</code> <p>Updated state estimate and covariance matrix of the estimate</p> Source code in <code>polar_tracking/kalman.py</code> <pre><code>def kalman_filter_update(measurement_matrix: npt.NDArray,\n                         observation: npt.NDArray,\n                         state_estimate: npt.NDArray,\n                         state_covariance: npt.NDArray,\n                         measurement_covariance: npt.NDArray \n    ) -&gt; tuple[npt.NDArray, npt.NDArray]:\n    \"\"\"Computes the Kalman Update Step\n\n    Args:\n        measurement_matrix: Matrix representing the measurement operator\n        observation: Current observation vector\n        state_estimate: State prediction for current timestep\n        state_covariance: Covariance matrix for current state prediction\n        measurement_covariance: Measurement covariance matrix\n\n    Returns:\n        Updated state estimate and covariance matrix of the estimate\n    \"\"\"\n\n    gain = kalman_gain(state_covariance,\n                       measurement_matrix,\n                       measurement_covariance)\n\n    state_estimate_update = state_estimate \\\n            - gain @ measurement_matrix @ state_estimate \\\n             + gain @ observation\n\n    state_covariance_update = state_covariance \\\n            - gain @ measurement_matrix @ state_covariance\n\n    return state_estimate_update, state_covariance_update\n</code></pre>"},{"location":"#polar_tracking.kalman.kalman_filter_prediction","title":"kalman_filter_prediction","text":"<pre><code>kalman_filter_prediction(\n    transition_matrix: npt.NDArray,\n    state_estimate: npt.NDArray,\n    state_covariance: npt.NDArray,\n    noise_covariance: npt.NDArray,\n) -&gt; tuple[npt.NDArray, npt.NDArray]\n</code></pre> <p>Computes the Kalman Prediction Step.</p> <p>Given the current MMSE state estimate and the transition matrix, compute the new state estimate and covariance matrix.</p> <p>Parameters:</p> Name Type Description Default <code>transition_matrix</code> <code>NDArray</code> <p>operator for advnacing the state</p> required <code>state_estimate</code> <code>NDArray</code> <p>Current MMSE state estimate</p> required <code>state_covariance</code> <code>NDArray</code> <p>Current estimate covariance</p> required <code>noise_covariance</code> <code>NDArray</code> <p>Covariance matrix of the system noise</p> required <p>Returns:</p> Type Description <code>tuple[NDArray, NDArray]</code> <p><code>(state_prediction, covariance_prediction)</code> where state_prediction is the updated state vector and  covariance_prediction is the covariance matrix of the prediction.</p> Source code in <code>polar_tracking/kalman.py</code> <pre><code>def kalman_filter_prediction(transition_matrix: npt.NDArray,\n                             state_estimate: npt.NDArray,\n                             state_covariance: npt.NDArray,\n                             noise_covariance: npt.NDArray\n    ) -&gt; tuple[npt.NDArray, npt.NDArray]:\n    \"\"\"Computes the Kalman Prediction Step.\n\n    Given the current MMSE state estimate and the transition matrix,\n    compute the new state estimate and covariance matrix.\n\n    Args:\n        transition_matrix: operator for advnacing the state\n        state_estimate: Current MMSE state estimate\n        state_covariance: Current estimate covariance\n        noise_covariance: Covariance matrix of the system noise\n\n    Returns:\n        `(state_prediction, covariance_prediction)`\n          where state_prediction is the updated state vector and \n          covariance_prediction is the covariance matrix of the prediction.\n    \"\"\"\n\n    state_prediction = transition_matrix @ state_estimate\n\n    covariance_prediction = transition_matrix \\\n                                @ state_covariance \\\n                                @ transition_matrix.T \\\n                                + noise_covariance\n\n    return state_prediction, covariance_prediction\n</code></pre>"}]}